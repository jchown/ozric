@using OzricEngine.logic
@using OzricUI.Model
@using OzricEngine.ext
@using Blazor.Diagrams.Components
@using Blazor.Diagrams.Core.Models.Base
@using OzricEngine
@implements IDisposable

<div class="diagram-container" style="height: 400px"><!-- Not sure why need to be hardcoded -->
    <CascadingValue Value="diagram">
        <DiagramCanvas></DiagramCanvas>
    </CascadingValue>
</div>

@code {

    [Parameter]
    public Graph Graph { get; set; }
    
    [Parameter]
    public GraphLayout GraphLayout { get; set; }
    
    [Parameter]
    public GraphEditState GraphEditState { get; set; }

    public Diagram diagram { get; set; }
    
    private bool IsChanged => !IsNotChanged;
    private bool IsNotChanged => history?.IsAtCheckpoint() ?? true;
    private bool CanUndo => GraphEditState.IsEditing && (history?.CanUndo() ?? false);
    private bool CanRedo => GraphEditState.IsEditing && (history?.CanRedo() ?? false);

    private EditHistory? history;
    
    private readonly Mapping<Node, GraphNodeModel> nodeMappings = new();
    private readonly Mapping<OzricEngine.nodes.Edge, LinkModel> edgeMappings = new();

    protected override async Task OnInitializedAsync()
    {
        await base.OnInitializedAsync();

        GraphEditState.OnChanged += OnGraphEditStateChanged;
        GraphEditState.OnDoUndo += OnDoUndo;
        GraphEditState.OnDoRedo += OnDoRedo;
        GraphEditState.OnDoSetCheckpoint += OnDoSetCheckpoint;
        GraphEditState.OnDoAdd += OnDoAdd;

        var options = new DiagramOptions
        {
            DeleteKey = "Delete", // What key deletes the selected nodes/links
            DefaultNodeComponent = null, // Default component for nodes
            AllowMultiSelection = true, // Whether to allow multi selection using CTRL
            Links = new DiagramLinkOptions
            {
            },
            Zoom = new DiagramZoomOptions
            {
                Minimum = 0.5, // Minimum zoom value
                Inverse = false, // Whether to inverse the direction of the zoom when using the wheel
            }
        };
        
        diagram = new Diagram(options);
        diagram.RegisterModelComponent<IfAnyModel, GraphNodeComponent>();
        diagram.RegisterModelComponent<SwitchModel, GraphNodeComponent>();
        diagram.RegisterModelComponent<DayPhasesModel, GraphNodeComponent>();
        diagram.RegisterModelComponent<SensorModel, GraphNodeComponent>();
        diagram.RegisterModelComponent<LightModel, GraphNodeComponent>();
        diagram.RegisterModelComponent<ModeSwitchModel, GraphNodeComponent>();
        diagram.SelectionChanged += OnSelectionChanged;
        
        PopulateDiagram();
        
        history = new EditHistory(this);
    }

    public void Dispose()
    {
        GraphEditState.OnChanged -= OnGraphEditStateChanged;
        GraphEditState.OnDoUndo -= OnDoUndo;
        GraphEditState.OnDoRedo -= OnDoRedo;
        GraphEditState.OnDoSetCheckpoint -= OnDoSetCheckpoint;
    }

    private void OnGraphEditStateChanged()
    {
        StateHasChanged();

        switch (GraphEditState.Mode)
        {
            case GraphEditState.EditMode.View:
            case GraphEditState.EditMode.Saving:
                SetLocked(true);
                break;
                
            case GraphEditState.EditMode.EditOffline:
            case GraphEditState.EditMode.EditOnline:
                SetLocked(false);
                break;
                
            default:
                throw new ArgumentOutOfRangeException();
        }
    }

    private void OnDoUndo()
    {
        history?.UndoLastAction();
        OnHistoryChanged();
    }

    private void OnDoRedo()
    {
        history?.RedoLastAction();
        OnHistoryChanged();
    }

    private void OnDoSetCheckpoint()
    {
        history?.SetCheckpoint();
        OnHistoryChanged();
    }
    
    private void OnDoAdd(List<Func<Node>> creators)
    {
        history?.Record(() =>
        {
            var ids = CreateNodes(creators);
            return new EditHistory.GraphAction.AddNodes(creators, ids);
        });
        OnHistoryChanged();
    }

    private void PopulateDiagram()
    {
        nodeMappings.Clear();
        edgeMappings.Clear();

        int x = 0, y = 0, w = 160, h = 120, cols = 6; 
        
        foreach (var node in Graph.nodes.Values)
        {
            var position = GraphLayout.nodeLayout.GetOrSet(node.id, () =>
            {
                var point = new LayoutPoint(x * w, y * h);
                if (++x == cols)
                {
                    x = 0;
                    ++y;
                }
                return point;
            }).ToPoint();

            AddNode(node, position);
        }

        foreach (var edge in Graph.edges.Values)
        {
            var fromD = nodeMappings.GetDiagram(edge.from.nodeID);
            var fromPortID = $"{edge.from.nodeID}.{edge.from.outputName}"; 
            
            var toD = nodeMappings.GetDiagram(edge.to.nodeID);
            var toPortID = $"{edge.to.nodeID}.{edge.to.inputName}";

            var link = new LinkModel(fromD.GetPort(fromPortID), toD.GetPort(toPortID))
            {
                Locked = !GraphEditState.IsEditing
            };

            edgeMappings.Add(edge, link);
            diagram.Links.Add(link);
        }
    }
    
    /// Take an existing node in the Graph and add it as the equivalent model object in the Diagram.
    /// The caller is expected to have added it to the DiagramLayout

    public void AddNode(Node node, Point position)
    {
        var diagramNode = NewNode(node, position);

        nodeMappings.Add(node, diagramNode);
        diagram.Nodes.Add(diagramNode);

        for (int i = 0; i < node.inputs.Count; i++)
        {
            diagramNode.Ports[i].Position = position.Add(0f, i * 20f);
        }
    }
    
    /// Remove the model object that represents the give node in the Graph from the Diagram

    public void RemoveNode(Node node)
    {
        var diagramNode = nodeMappings.Remove(node);
        diagram.Nodes.Remove(diagramNode);
    }

    private GraphNodeModel NewNode(Node node, Point? point = null)
    {
        GraphNodeModel model;
        switch (node)
        {
            case Light l:
            {
                model = new LightModel(l, point);
                break;
            }
            case Sensor s:
            {
                model = new SensorModel(s, point);
                break;
            }
            case Switch s:
            {
                model = new SwitchModel(s, point);
                break;
            }
            case ModeSwitch ms:
            {
                model = new ModeSwitchModel(ms, point);
                break;
            }
            case IfAny ia:
            {
                model = new IfAnyModel(ia, point);
                break;
            }
            case DayPhases dp:
            {
                model = new DayPhasesModel(dp, point);
                break;
            }
            default:
            {
                throw new Exception($"Unhandled type {node.GetType()}");
            }
        }
        model.Moving += OnNodeModelMoving;
        model.Locked = !GraphEditState.IsEditing; 
        return model;
    }

    private void OnNodeModelMoving(NodeModel nodeModel)
    {
        var nodeID = nodeMappings.GetGraph(nodeModel.Id).id;
        if (nodeID == null)
            throw new Exception("Node not found");

        var from = GraphLayout.nodeLayout[nodeID].ToPoint();
        var to = nodeModel.Position;
        
        GraphLayout.nodeLayout[nodeID] = LayoutPoint.FromPoint(to);
        history.Node_Moved(nodeModel, from, to);

        OnHistoryChanged();
    }

    private void OnHistoryChanged()
    {
        GraphEditState.SetHistoryState(history);
    }

    private void SetLocked(bool locked)
    {
        foreach (var node in diagram.Nodes)
        {
            node.Locked = locked;

            foreach (var port in node.Ports)
                port.Locked = locked;
        }

        foreach (var link in diagram.Nodes)
            link.Locked = locked;
    }

    public List<string> CreateNodes(List<Func<Node>> nodeCreators)
    {
        var pos = new Point(20, 20);
        var nodeIDs = new List<string>(nodeCreators.Count);
                
        foreach (var nodeCreator in nodeCreators)
        {
            var node = nodeCreator();
            Graph.AddNode(node);
            GraphLayout.nodeLayout[node.id] = LayoutPoint.FromPoint(pos);
            AddNode(node, pos);
            pos = pos.Add(20, 0);
            nodeIDs.Add(node.id);
        }

        return nodeIDs;
    }

    private void OnSelectionChanged(SelectableModel obj)
    {
        GraphEditState.SetSelected(diagram.GetSelectedModels().ToList());
    }

}
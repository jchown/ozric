@page "/graph"

<PageTitle>Graph</PageTitle>

@using OzricUI.Data
@using Blazor.Diagrams.Components
@using OzricEngine
@using OzricEngine.ext
@using OzricEngine.logic
@using OzricEngine.nodes
@using OzricUI.Model
@inject OzricEngineService ozricEngine

<div class="top-row px-2 py-2">

    <MatButton Icon="edit" Raised="true" @onclick="OnClickEdit" Disabled="@IsEditing" hidden="@IsEditing">
        Edit
    </MatButton>

    <MatButton Icon="cancel" Raised="true" @onclick="OnClickCancel" Disabled="@IsNotEditing" hidden="@IsNotEditing">
        Cancel
    </MatButton>

    <MatButton Icon="save" Raised="true" @onclick="OnClickSave" Disabled="@IsNotChanged" hidden="@IsNotEditing">
        Save
    </MatButton>

    <MatButton Icon="undo" Raised="true" @onclick="OnClickUndo" Disabled="@CanNotUndo" hidden="@IsNotEditing">
        Undo
    </MatButton>

    <MatButton Icon="redo" Raised="true" @onclick="OnClickRedo" Disabled="@CanNotRedo" hidden="@IsNotEditing">
        Redo
    </MatButton>
    
</div>


@if (graph == null)
{
    <p><em>Loading...</em></p>
}
else
{
    <div class="diagram-container">
        <CascadingValue Value="diagram">
            <DiagramCanvas></DiagramCanvas>
        </CascadingValue>
    </div>
}

@code {

    enum EditMode
    {
        View, EditOffline, EditOnline
    }
    
    enum OnlineMode
    {
        Realtime, Simulated
    }

    private EditMode mode = EditMode.View;
    
    private bool IsEditing => mode != EditMode.View;
    private bool IsNotEditing => mode == EditMode.View;
    private bool IsChanged => history?.IsAtCheckpoint() ?? false;
    private bool IsNotChanged => !IsChanged;
    private bool CanUndo => history?.CanUndo() ?? false;
    private bool CanRedo => history?.CanRedo() ?? false;
    private bool CanNotUndo => !CanUndo;
    private bool CanNotRedo => !CanRedo;

    private OzricEngine.Graph? graph;
    private GraphLayout? graphLayout;
    
    private Mapping<Node, GraphNodeModel> nodeMappings = new();
    private Mapping<Edge, LinkModel> edgeMappings = new();

    private Diagram? diagram { get; set; }
    private DiagramHistory? history;

    protected override async Task OnInitializedAsync()
    {
        await base.OnInitializedAsync();

        await Load();
    }
    
    private async Task Load()
    {
        graph = await ozricEngine.GetGraphAsync();
        graphLayout = await ozricEngine.GetGraphLayoutAsync();
        
        var options = new DiagramOptions
        {
            DeleteKey = "Delete", // What key deletes the selected nodes/links
            DefaultNodeComponent = null, // Default component for nodes
            AllowMultiSelection = true, // Whether to allow multi selection using CTRL
            Links = new DiagramLinkOptions
            {
            },
            Zoom = new DiagramZoomOptions
            {
                Minimum = 0.5, // Minimum zoom value
                Inverse = false, // Whether to inverse the direction of the zoom when using the wheel
            }
        };
        
        diagram = new Diagram(options);
        
        PopulateDiagram();
        
        history = new DiagramHistory(diagram);
    }

    private void OnClickEdit()
    {
        mode = EditMode.EditOffline;

        SetLocked(false);
    }

    private async Task OnClickSave()
    {
        await ozricEngine.SetGraphLayoutAsync(graphLayout);
        history.SetCheckpoint();
    }

    private async Task OnClickCancel()
    {
        mode = EditMode.View;

        Load();
    }

    private void OnClickUndo()
    {
        history?.UndoLastAction();
    }

    private void OnClickRedo()
    {
        history?.RedoLastAction();
    }
        
    private void PopulateDiagram()
    {
        nodeMappings.Clear();
        edgeMappings.Clear();

        int x = 0, y = 0, w = 160, h = 120, cols = 6; 
        
        foreach (var node in graph.nodes)
        {
            var diagramNode = NewNode(node.Value, graphLayout.nodeLayout.GetOrSet(node.Key, () =>
            {
                var point = new LayoutPoint(x * w, y * h);
                if (++x == cols)
                {
                    x = 0;
                    ++y;
                }
                return point;
            }).ToPoint());
            
            nodeMappings.Add(node.Value, diagramNode);
            diagram.Nodes.Add(diagramNode);
        }

        foreach (var edge in graph.edges.Values)
        {
            var fromD = nodeMappings.GetDiagram(edge.from.nodeID); 
            var toD = nodeMappings.GetDiagram(edge.to.nodeID);

            var link = new LinkModel(fromD.GetPort(PortAlignment.Right), toD.GetPort(PortAlignment.Left));
            link.Locked = IsNotEditing;
            
            edgeMappings.Add(edge, link);
            diagram.Links.Add(link);
        }
    }

    private GraphNodeModel NewNode(Node node, Point? point = null)
    {
        GraphNodeModel model;
        switch (node)
        {
            case Light l:
            {
                model = new LightModel(l, point);
                break;
            }
            case Sensor s:
            {
                model = new SensorModel(s, point);
                break;
            }
            case Switch s:
            {
                model = new SwitchModel(s, point);
                break;
            }
            case ModeSwitch ms:
            {
                model = new ModeSwitchModel(ms, point);
                break;
            }
            case IfAny ia:
            {
                model = new IfAnyModel(ia, point);
                break;
            }
            case DayPhases dp:
            {
                model = new DayPhasesModel(dp, point);
                break;
            }
            default:
            {
                throw new Exception($"Unhandled type {node.GetType()}");
            }
        }
        model.Moving += OnNodeModelMoving;
        model.Locked = IsNotEditing; 
        return model;
    }

    private void OnNodeModelMoving(NodeModel nodeModel)
    {
        var nodeID = nodeMappings.GetGraph(nodeModel.Id).id;
        if (nodeID == null)
            throw new Exception("Node not found");

        var from = graphLayout.nodeLayout[nodeID].ToPoint();
        var to = nodeModel.Position;
        
        graphLayout.nodeLayout[nodeID] = LayoutPoint.FromPoint(to);
        history.Node_Moved(nodeModel, from, to);

        StateHasChanged();
    }
    
    private void SetLocked(bool locked)
    {
        foreach (var node in diagram.Nodes)
            node.Locked = locked;
        
        foreach (var link in diagram.Nodes)
            link.Locked = locked;
    }
    
}

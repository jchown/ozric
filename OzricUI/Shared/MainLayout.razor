@using OzricUI.Data
@using OzricEngine
@using OzricEngine.logic
@using OzricEngine.nodes
@using OzricService
@using OzricUI.Components 
@using OzricUI.Model
@using Size = MudBlazor.Size
@using Edge = MudBlazor.Edge
@inject IDialogService DialogService
@inherits LayoutComponentBase
@inject DataService Data
@inject IEngineService EngineService

<MudThemeProvider/>
<MudDialogProvider/>
<MudSnackbarProvider/>
<MudThemeProvider @ref="@_mudThemeProvider" @bind-IsDarkMode="@_isDarkMode"/>

<MudLayout>
    <MudAppBar>
        <MudIconButton Icon="@Icons.Material.Filled.Menu" Color="Color.Inherit" Edge="Edge.Start" OnClick="@((_) => DrawerToggle())" />
        
        <MudText>Ozric</MudText>
 
        <MudSpacer />

        <MudTooltip Text="Add" Arrow="true" Placement="Placement.Top">
            <MudIconButton Icon="@Icons.Material.Filled.Add" Variant="Variant.Filled" Color="Color.Primary" @onclick="OnClickAdd" Disabled="@(!IsEditing)" hidden="@(!IsEditing)" />
        </MudTooltip>

        <MudTooltip Text="Delete" Arrow="true" Placement="Placement.Top">
            <MudIconButton Icon="@Icons.Material.Filled.Delete" Variant="Variant.Filled" Color="Color.Primary" @onclick="OnClickDel" Disabled="@(!HasSelection)" hidden="@(!IsEditing)" />
        </MudTooltip>

        <MudSpacer></MudSpacer>
        
        <MudButton StartIcon="@Icons.Material.Filled.Edit" Variant="Variant.Filled" Color="Color.Primary" OnClick="@OnClickEdit" Disabled="@IsEditing" Hidden="@IsEditing">
            Edit
        </MudButton>
        
        <MudButton StartIcon="@Icons.Material.Filled.Cancel" Variant="Variant.Filled" Color="Color.Primary" @onclick="OnClickCancel" Disabled="@(Saving || !IsEditing)" hidden="@(!IsEditing)">
            Cancel
        </MudButton>
               
        <MudButton Color="Color.Tertiary" Variant="Variant.Filled"  @onclick="OnClickSave" Disabled="@(Saving || !IsChanged)" hidden="@(!IsEditing)">
            @if (Saving)
            {
                <MudProgressCircular Class="ms-n1" Size="Size.Small" Indeterminate="true"/>
                <MudText Class="ms-2">Saving</MudText>
            }
            else
            {
                <MudIcon Variant="Variant.Filled" Icon="@Icons.Material.Filled.Save" />
                <MudText>Save</MudText>
            }
        </MudButton>

        <MudTooltip Text="Undo" Arrow="true" Placement="Placement.Top">
            <MudIconButton Icon="@Icons.Material.Filled.Undo" Variant="Variant.Filled" Color="Color.Primary" @onclick="OnClickUndo" Disabled="@(!CanUndo)" hidden="@(!IsEditing)" />
        </MudTooltip>
        
        <MudTooltip Text="Redo" Arrow="true" Placement="Placement.Top">
            <MudIconButton Icon="@Icons.Material.Filled.Redo" Variant="Variant.Filled" Color="Color.Primary" @onclick="OnClickRedo" Disabled="@(!CanRedo)" hidden="@(!IsEditing)" />
        </MudTooltip>
        
    </MudAppBar>
    <MudDrawer @bind-Open="@_drawerOpen">
        <NavMenu/>
    </MudDrawer>
    <MudMainContent>
        
        <div style="height: 100%">
        @if (Graph == null || GraphLayout == null)
        {
            <MudPaper Class="pa-16 ma-2" Outlined="true">
                <MudText>Loading...&#160;&#160;&#160;<MudProgressCircular Size="Size.Small" Indeterminate="true"/></MudText>
            </MudPaper>
        }
        else
        {
            <GraphEditor Graph="@Graph" GraphLayout="@GraphLayout" GraphEditState="@GraphEditState" />
        }
        </div>
    </MudMainContent>
</MudLayout>

@code {
    bool _drawerOpen = true;
    private bool _isDarkMode;
    private MudThemeProvider? _mudThemeProvider;

    private Graph Graph { get; set; }
    private GraphLayout GraphLayout { get; set; }
    private GraphEditState GraphEditState { get; set; } = new();

    private bool Saving => GraphEditState.Mode == GraphEditState.EditMode.Saving;
    private bool HasSelection => GraphEditState.Selected.Count > 0; 

    public bool IsEditing => GraphEditState.IsEditing;
    public bool IsChanged => GraphEditState.IsChanged;
    public bool CanUndo => GraphEditState.CanUndo && !Saving;
    public bool CanRedo => GraphEditState.CanRedo && !Saving;

    void DrawerToggle()
    {
        _drawerOpen = !_drawerOpen;
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            var task = _mudThemeProvider?.GetSystemPreference();
            var dark = (task != null) && await task;
            _isDarkMode = false && dark;
            StateHasChanged();
        }
    }

    protected override async Task OnInitializedAsync()
    {
        await LoadGraph();
    }

    private async Task LoadGraph()
    {
        Graph = EngineService.Graph;
        GraphLayout = await Data.GetGraphLayoutAsync();
        GraphEditState.OnChanged += OnGraphEditStateChanged;
    }

    private void UnloadGraph()
    {
        GraphEditState.OnChanged -= OnGraphEditStateChanged;
        Graph = new();
        GraphLayout = new();
        GraphEditState = new();
    }

    private void OnGraphEditStateChanged()
    {
        StateHasChanged();
    }

    private void OnClickEdit()
    {
        GraphEditState.OnEdit();
    }

    private void OnClickCancel()
    {
        if (!GraphEditState.IsChanged)
        {
            GraphEditState.OnCancel();
            return;
        }
     
        //  Tear down and rebuild. It would be nice to do something less brutal.
        
        UnloadGraph();
        
        _ = Task.Run(async () =>
        {
            await LoadGraph();
            await InvokeAsync(StateHasChanged);
        });
    }

    private void OnClickSave()
    {
        if (GraphLayout == null)
            throw new Exception();
        
        GraphEditState.OnSaving();
        _ = Task.Run(async () =>
        {
            try
            {
                await Task.Delay(100);
                await EngineService.Restart(Graph);
                await Data.SetGraphLayoutAsync(GraphLayout);
                await InvokeAsync(() => GraphEditState.DoSetCheckpoint());
            }
            catch (Exception e)
            {
                Console.Error.WriteLine(e.ToString());
            }
            finally
            {
                await InvokeAsync(() => GraphEditState.OnEdit());
            }
        });
    }

    private void OnClickUndo()
    {
        GraphEditState.DoUndo();
    }

    private void OnClickRedo()
    {
        GraphEditState.DoRedo();
    }
    
    private async Task OnClickAdd()
    {
        var options = new DialogOptions
        {
            CloseOnEscapeKey = true,
            CloseButton = true,
            Position = DialogPosition.TopCenter,
            MaxWidth = MaxWidth.Medium,
            FullWidth = true
        };
        
        var devices = EngineService.Home.states;
        var choices = devices.Select(device =>
        {
            AddNodeChoice? choice = null;

            if (Graph.GetDevicesNode(device.Key) == null)
            {
                if (device.Value.IsLight())
                {
                    choice = new AddNodeChoice(
                        category: Category.Light,
                        name: device.Key,
                        icon: LightModel.ICON,
                        create: () => new Light(Graph.CreateNodeID("light"), device.Key),
                        once: true);
                }
                else if (device.Value.IsSensor())
                {
                    choice = new AddNodeChoice(
                        category: Category.MotionSensor,
                        name: device.Key,
                        icon: SensorModel.ICON,
                        create: () => new Sensor(Graph.CreateNodeID("sensor"), device.Key),
                        once: true);
                }
            }

            return choice;
        }).Where(choices => choices != null).ToList();

        choices.Add(new AddNodeChoice(
            category: Category.Logic, 
            name: "If Any - OR", 
            icon: IfAnyModel.ICON, 
            create: () => new IfAny(Graph.CreateNodeID("ifany-"), "input1", "input2"),
            once: false));
        
        choices.Add(new AddNodeChoice(
            category: Category.Logic,
            name: "If All - AND",
            icon: IfAllModel.ICON,
            create: () => new IfAny(Graph.CreateNodeID("ifall-"), "input1", "input2"),
            once: false));

        var parameters = new DialogParameters();
        parameters.Add("Choices", choices);
        
        var result = await DialogService.Show<AddNodesDialog>("Add Nodes", parameters, options).Result;
        if (result.Cancelled)
            return;

        var selected = result.Data as List<AddNodeChoice>;
        if (selected == null)
            return;

        GraphEditState.DoAdd(selected.Select(anc => anc.Create).ToList());
    }

    private void OnClickDel()
    {
        
    }
}
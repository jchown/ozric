@using OzricUI.Data
@using OzricEngine
@using OzricEngine.Nodes
@using OzricEngine.Values
@using OzricService
@using OzricUI.Components
@using OzricUI.Model
@using Size = MudBlazor.Size
@using Edge = MudBlazor.Edge
@using Blazor.Diagrams.Core.Models.Base
@using Microsoft.AspNetCore.SignalR.Client
@using OzricUI.Hubs
@using System.Reflection
@inject IDialogService DialogService
@inherits LayoutComponentBase
@inject DataService Data
@inject IOzricService OzricService
@inject NavigationManager Navigation
@inject IJSRuntime JS

@* Why is this needed? If I remove it, we get no HHC events *@
@inject HomeHubController HHC

<PageTitle>Ozric - Graph</PageTitle>

<MudDialogProvider/>
<MudSnackbarProvider/>
<MudThemeProvider @ref="@_mudThemeProvider" @bind-IsDarkMode="@_isDarkMode"/>

<CascadingValue Value="@OzricService">
<MudLayout>
    <MudAppBar>
        <MudIconButton Icon="@Icons.Material.Filled.Menu" Color="Color.Inherit" Edge="Edge.Start" OnClick="@((_) => DrawerToggle())" />
        
        <MudText>Ozric</MudText>
        
        &nbsp; &nbsp;
        
        <MudIconButton Title="Pause Engine" Icon="@Icons.Material.Filled.PauseCircle" Variant="Variant.Filled" Color="Color.Primary" @onclick="OnClickPause" Disabled="@(IsEditing || OzricService.Status.paused)" />
        <MudIconButton Title="Continue Engine" Icon="@Icons.Material.Filled.PlayCircle" Variant="Variant.Filled" Color="Color.Primary" @onclick="OnClickContinue" Disabled="@(IsEditing || !OzricService.Status.paused)" />
        <MudIconButton Title="Restart Engine" Icon="@Icons.Material.Filled.RestartAlt" Variant="Variant.Filled" Color="Color.Primary" @onclick="OnClickRestart" Disabled="@(IsEditing)" />
 
        <MudSpacer />

        <MudButton StartIcon="@Icons.Material.Filled.Add" Variant="Variant.Filled" Color="Color.Primary" @onclick="OnClickAdd" Disabled="@(!IsEditing)" hidden="@(!IsEditing)">
            Add
        </MudButton>

        <MudButton StartIcon="@Icons.Material.Filled.Delete" Variant="Variant.Filled" Color="Color.Primary" @onclick="OnClickDelete" Disabled="@(!HasSelection)" hidden="@(!IsEditing)">
            Delete
        </MudButton>

        <MudButton StartIcon="@Icons.Material.Filled.Info" Variant="Variant.Filled" Color="Color.Primary" OnClick="@OnClickInfo" Disabled="@(!CanGetInfo)">
            Info
        </MudButton>

        <MudSpacer />

        <MudButton StartIcon="@Icons.Material.Filled.Group" Variant="Variant.Filled" Color="Color.Primary" @onclick="OnClickGroup" Disabled="@(!CanGroupSelection())" hidden="@(!IsEditing)">
            Group
        </MudButton>

        <MudButton StartIcon="@Icons.Material.Filled.GroupOff" Variant="Variant.Filled" Color="Color.Primary" @onclick="OnClickUngroup" Disabled="@(!CanUngroupSelection())" hidden="@(!IsEditing)">
            Ungroup
        </MudButton>

        <MudSpacer />
        
        <MudButton StartIcon="@Icons.Material.Filled.Edit" Variant="Variant.Filled" Color="Color.Primary" OnClick="@OnClickEdit" Disabled="@IsEditing" hidden="@IsEditing">
            Edit
        </MudButton>
        
        <MudButton StartIcon="@Icons.Material.Filled.Cancel" Variant="Variant.Filled" Color="Color.Primary" @onclick="OnClickDone" Disabled="@(Saving || !IsEditing)" hidden="@(!IsEditing)"> 
            Done
        </MudButton>
                
        <MudButton Color="Color.Tertiary" Variant="Variant.Filled"  @onclick="OnClickSave" Disabled="@(Saving || !IsChanged)" hidden="@(!IsEditing)">
            @if (Saving)
            {
                <MudProgressCircular Class="ms-n1" Size="Size.Small" Indeterminate="true"/>
                <MudText Class="ms-2">Saving</MudText>
            }
            else
            {
                <MudIcon Variant="Variant.Filled" Icon="@Icons.Material.Filled.Save" />
                <MudText>Save</MudText>
            }
        </MudButton>

        <MudTooltip Text="Undo" Arrow="true" Placement="Placement.Top">
            <MudIconButton Icon="@Icons.Material.Filled.Undo" Variant="Variant.Filled" Color="Color.Primary" @onclick="OnClickUndo" Disabled="@(!CanUndo)" hidden="@(!IsEditing)" />
        </MudTooltip>
        
        <MudTooltip Text="Redo" Arrow="true" Placement="Placement.Top">
            <MudIconButton Icon="@Icons.Material.Filled.Redo" Variant="Variant.Filled" Color="Color.Primary" @onclick="OnClickRedo" Disabled="@(!CanRedo)" hidden="@(!IsEditing)" />
        </MudTooltip>
        
    </MudAppBar>
    
    <MudDrawer @bind-Open="@_settingsDrawerOpen">
        <NavMenu/>
    </MudDrawer>
    
    <MudMainContent>
        
        <div style="height: 100%">
            @if (Graph == null || GraphLayout == null)
            {
                <MudPaper Class="pa-16 ma-2" Outlined="true">
                    <MudText>Loading...&#160;&#160;&#160;<MudProgressCircular Size="Size.Small" Indeterminate="true"/></MudText>
                </MudPaper>
            }
            else
            {
                <GraphEditor Graph="@Graph" GraphLayout="@GraphLayout" GraphEditState="@GraphEditState" />
            }
        </div>
    </MudMainContent>

</MudLayout>
</CascadingValue>

@code {
    bool _settingsDrawerOpen = false;
    private bool _isDarkMode;
    private MudThemeProvider? _mudThemeProvider;

    private Graph Graph { get; set; }
    private GraphLayout GraphLayout { get; set; }
    private GraphEditState GraphEditState { get; set; } = new();
    private List<KeyValuePair<SelectableModel, IGraphObject>> SelectedItems { get; set; } = new();
    private HubConnection? hubConnection;

    private bool Saving => GraphEditState.Mode == GraphEditState.EditMode.Saving;
    private bool HasSelection => (SelectedItems.Count > 0);
    private bool CanGetInfo => SelectedItems.Count == 1 && SelectedItems[0].Key is GraphNodeModel;
    private List<string> log = new();

    public bool IsEditing => GraphEditState.IsEditing;
    public bool IsChanged => GraphEditState.IsChanged;
    public bool CanUndo => GraphEditState.CanUndo && !Saving;
    public bool CanRedo => GraphEditState.CanRedo && !Saving;


    void DrawerToggle()
    {
        _settingsDrawerOpen = !_settingsDrawerOpen;
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            var task = _mudThemeProvider?.GetSystemPreference();
            var dark = (task != null) && await task;
            _isDarkMode = false && dark;
            StateHasChanged();
        }

        if (log.Count == 0)
            return;

        var toLog = log;
        log = new();

        foreach (var log in toLog)
            await JS.InvokeVoidAsync("console.log", log);
    }

    protected override async Task OnInitializedAsync()
    {
        await LoadGraph();

        try
        {
            hubConnection = new HubConnectionBuilder()
                .WithAutomaticReconnect()
                .WithUrl(Navigation.ToAbsoluteUri(HomeHub.ENDPOINT))
                .AddJsonProtocol(json => Json.Configure(json.PayloadSerializerOptions))
    // .ConfigureLogging(logging =>
    // {
    //     logging.AddConsole();
    //     logging.SetMinimumLevel(Microsoft.Extensions.Logging.LogLevel.Trace);
    // })
                .Build();

            hubConnection.On<Value>(HomeHub.TEST_MESSAGE, (v) =>
            {
                Console.WriteLine("Value: {0}", v);
            });

            hubConnection.On<string>(HomeHub.HEARTBEAT_MESSAGE, (m) =>
            {
            });

            hubConnection.On<EventStateChanged>(HomeHub.ENTITY_STATE_CHANGED_MESSAGE, (esc) =>
            {
                InvokeAsync(() =>
                {
                    OzricService.Home.OnEventStateChanged(esc);
                    if (GraphEditState.IsLocked())
                        GraphEditState.RefreshEntity(esc.data.new_state.entity_id);

                    StateHasChanged();
                });
            });

            hubConnection.On<string, string, string>(HomeHub.PIN_CHANGED_MESSAGE, (nodeID, pinName, value) =>
            {
                InvokeAsync(() =>
                {
                    GraphEditState.PinChanged(nodeID, pinName, Json.Deserialize<Value>(value));
                    StateHasChanged();
                });
            });

            await hubConnection.StartAsync();
        }
        catch (Exception e)
        {
            log.Add($"Hub init failed: {e.Message}");
        }
    }

    private async Task LoadGraph()
    {
        log.Add("Loading graph");
        Graph = Json.Clone(OzricService.Graph); // Don't edit the live graph!
        log.Add($"Loaded {Graph.nodes.Count} nodes");

        log.Add("Loading graph layout");
        GraphLayout = await Data.GetGraphLayoutAsync();
        log.Add($"Loaded {GraphLayout.nodeLayout.Count} node positions");

        GraphEditState.OnChanged += OnGraphEditStateChanged;
        GraphEditState.OnSelectionChanged += GraphSelectionChanged;
        GraphEditState.OnKeyDown += OnDiagramKeyDown;
    }

    private void UnloadGraph()
    {
        GraphEditState.OnChanged -= OnGraphEditStateChanged;
        Graph = new Graph();
        GraphLayout = new GraphLayout();
        GraphEditState = new GraphEditState();
    }

    private void OnGraphEditStateChanged()
    {
        if (GraphEditState.IsEditing && !OzricService.Status.paused)
            OzricService.SetPaused(true);

        if (!GraphEditState.IsEditing && OzricService.Status.paused)
            OzricService.SetPaused(false);

        StateHasChanged();
    }

    private void OnClickEdit()
    {
        GraphEditState.OnEdit();
    }

    private void OnClickDone()
    {
        if (!GraphEditState.IsChanged)
        {
            GraphEditState.OnCancel();
            return;
        }

    //  Tear down and rebuild. It would be nice to do something less brutal.

        UnloadGraph();

        _ = Task.Run(async () =>
        {
            await LoadGraph();
            await InvokeAsync(StateHasChanged);
        });
    }

    private async Task OnClickSave()
    {
        if (GraphLayout == null)
            throw new Exception();

        GraphEditState.OnSaving();
        try
        {
            await OzricService.Restart(Graph);
            await Data.SetGraphLayoutAsync(GraphLayout);
            await InvokeAsync(() => GraphEditState.DoCommand(GraphEditState.Command.SetCheckpoint));
        }
        catch (Exception e)
        {
            Console.Error.WriteLine(e.ToString());
        }
        finally
        {
            await InvokeAsync(() => GraphEditState.OnEdit());
        }
    }

    private void OnClickUndo()
    {
        GraphEditState.DoCommand(GraphEditState.Command.Undo);
    }

    private void OnClickRedo()
    {
        GraphEditState.DoCommand(GraphEditState.Command.Redo);
    }

    private void OnClickPause()
    {
        OzricService.SetPaused(true);
    }

    private void OnClickContinue()
    {
        OzricService.SetPaused(false);
    }

    private void OnClickRestart()
    {
        OzricService.Restart(OzricService.Graph);
    }

    private async Task OnClickAdd()
    {
        Action<Node> addNode = AddNode;

        var parameters = new DialogParameters
        {
            { "Choices", AddNodeChoice.GetChoices(OzricService.Home, Graph) },
            { "OnAdd", addNode }
        };

        await DialogService.Show<AddNodesDialog>("Add Nodes", parameters, GetDialogOptions()).Result;
    }

    private void AddNode(Node node)
    {
        GraphEditState.DoAction(new GraphEditAction.AddNode(node));
    }

    private void GraphSelectionChanged(List<KeyValuePair<SelectableModel, IGraphObject>> items)
    {
        SelectedItems = items;
        StateHasChanged();
    }

    private async Task OnClickInfo()
    {
        if (SelectedItems.Count != 1)
            return;

        var (model, node) = SelectedItems[0];
        if (model is not GraphNodeModel gm)
            return;

        var editDialog = model.GetType().GetCustomAttribute<EditDialogAttribute>()!;
        await ShowNodeDialog(model, node, editDialog.type, editDialog.title);
    }

    private async Task ShowNodeDialog(SelectableModel model, IGraphObject node, Type type, string title)
    {
        var parameters = new DialogParameters
        {
            { "Model", model },
            { "Node", node }
        };

        var options = GetDialogOptions();

        var result = await DialogService.Show(type, title, parameters, options).Result;
        if (result.Cancelled)
            return;

        var changes = (List<GraphEditAction>)result.Data;
        if (changes.Count == 0)
            return;

        if (GraphEditState.Mode == GraphEditState.EditMode.View)
            GraphEditState.OnEdit();

        GraphEditState.DoAction(new GraphEditAction.EditActions(changes));
        StateHasChanged();
    }

    private async Task OnClickData()
    {
        var parameters = new DialogParameters
        {
            { "Graph", Json.Prettify(Json.Serialize(Graph)) },
            { "GraphLayout", Json.Prettify(Json.Serialize(GraphLayout)) }
        };

        var options = GetDialogOptions();

        var result = await DialogService.Show(typeof(DataDialog), "Raw Data", parameters, options).Result;
        if (result.Cancelled)
            return;

        var json = (DataDialog.Result)result.Data;

        Graph = Json.Deserialize<Graph>(json.graph);
        GraphLayout = Json.Deserialize<GraphLayout>(json.graphLayout);

        await OnClickSave();
    }

    private static DialogOptions GetDialogOptions()
    {
        var options = new DialogOptions
        {
            CloseOnEscapeKey = true,
            CloseButton = true,
            Position = DialogPosition.TopCenter,
            MaxWidth = MaxWidth.Medium,
            FullWidth = true
        };
        return options;
    }

    private Task OnClickDelete()
    {
        GraphEditState.DoCommand(GraphEditState.Command.Delete);
        return Task.CompletedTask;
    }

    private void OnClickGroup()
    {
        GraphEditState.DoAction(GraphEditAction.Build(GroupActions()));
    }
    
    private IEnumerable<GraphEditAction> GroupActions()
    {
        //  Either all nodes are in no group, or there is at least one in an existing group.
        
        var nodeInGroup = SelectedItems.FirstOrDefault(kv => (kv.Key as GraphNodeModel)?.Group != null);
        var group = (nodeInGroup.Key as GraphNodeModel)?.Group as ZoneModel;

        if (group == null)
        {
            //  Not joining an existing group
            
            var zoneID = GraphLayout.NewZoneID();
            yield return new GraphEditAction.AddGroup(zoneID);
            
            var nodeIDs = SelectedItems.Where(kv => kv.Value is Node).Select(kv => kv.Value.id).ToList();
            yield return new GraphEditAction.AddNodesToGroup(zoneID, nodeIDs);
        }
        else
        {
            var zoneID = group.zoneID;
            var nodeIDs = SelectedItems.Where(kv => (kv.Key as GraphNodeModel)?.Group == null).Select(kv => kv.Value.id).ToList();
            yield return new GraphEditAction.AddNodesToGroup(zoneID, nodeIDs);
        }
    }
    
    private void OnClickUngroup()
    {
        GraphEditState.DoAction(GraphEditAction.Build(UngroupActions()));
    }

    private IEnumerable<GraphEditAction> UngroupActions()
    {
        var nodesByGroup = SelectedItems.GroupBy(kv => (kv.Key as GraphNodeModel)?.Group).Where(g => g.Key != null);

        yield return new GraphEditAction.RemoveNodesFromGroups(SelectedItems.Where(kv => kv.Value is Node).Select(kv => kv.Value.id).ToList());

        foreach (var nodeGroup in nodesByGroup)
        {
            var group = (ZoneModel) nodeGroup.Key!;
            var zoneID = group.zoneID;
            if (GraphLayout.zones[zoneID].nodeIDs.Count == nodeGroup.Count())
            {
                yield return new GraphEditAction.RemoveGroup(zoneID);
            }
        }
    }
    
    private bool CanGroupSelection()
    {
        // Can group 2+ ungrouped items, or 1+ ungrouped items with 1+ items in a single other group 

        if (SelectedItems.Count < 2)
            return false;

        var groups = SelectedItems
            .Where(i => i.Key is GraphNodeModel)
            .GroupBy(i => ((GraphNodeModel)i.Key).Group?.Id)
            .ToList();

        if (groups.Count > 2)
            return false;

        var ungrouped = groups.FirstOrDefault(g => g.Key == null);
        if (ungrouped == null)
            return false;

        var grouped = groups.FirstOrDefault(g => g.Key != null);

        return (grouped != null) || (ungrouped.Count() > 1);
    }

    private bool CanUngroupSelection()
    {
        return SelectedItems.Any(i => i.Key is GraphNodeModel gm && gm.Group != null);
    }
    
    private void OnDiagramKeyDown(KeyboardEventArgs e)
    {
        if (e.CtrlKey && e.Key.Equals("z"))
        {
            GraphEditState.DoCommand(GraphEditState.Command.Undo);
        }
        else if (e.CtrlKey && e.Key.Equals("y"))
        {
            GraphEditState.DoCommand(GraphEditState.Command.Redo);
        }
        else if (e.Key == "Delete")
        {
            GraphEditState.DoCommand(GraphEditState.Command.Delete);
        }
    }
}